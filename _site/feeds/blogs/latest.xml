<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>API Specification Toolbox</title>
  <updated></updated>
  <link rel="self" href="http://localhost:4000/atom.xml"/>
  <author><name>Kin Lane</name></author>
  <id>http://localhost:4000/atom.xml</id>
	<entry>
    <title>Reference, Capability, and Workflow Jira API Collections</title>
    <link href="http://localhost:4000/2020/12/19/reference-capability-and-workflow-jira-api-collections/"/>
    <updated></updated>
    <content><![CDATA[
I have struggled to properly articulate to partners the potential of publishing API collections to the Postman API network, as well as via public workspaces. Most folks I talk to see Postman collections similar to how they see an OpenAPI&amp;mdash;a reference of every path available via an API. While Postman collections excel at being in the service of publishing reference documentation, or used as an interactive API client, they can be much more.&amp;nbsp; I am seeing a natural progression in the types of collections API providers are&amp;nbsp; publishing, which results in a robust mix of collections that describe everything that is possible with an API, but also what capabilities an API platform provides, as well as workflow collections that accomplish specific business tasks.&amp;nbsp;To help me demonstrate the different types of Postman collections I wanted to take the JIRA Cloud Platform API and publish a variety of collections to a public workspace&amp;mdash;helping make the concept more relative to people across the enterprise landscape.
Reference API Collections
Most API Providers begin with publishing what is a reference API collection, providing a full menu of what is possible across the entire surface area of an API. This is where collections most reflect OpenAPI by providing an entire machine readable menu of what an API delivers so that it can be used to publish documentation. While some API Providers hand craft Postman collections for their entire menu of APIs in this way I recommend defining the surface area of your API using OpenAPI ,then generate a collection from the OpenAPI truth&amp;mdash;something Postman will help you do, and then keep in sync with the OpenAPI source. For this story, I have downloaded Atlassian Jira&amp;rsquo;s OpenAPI, imported into Postman, and selected the option to automatically generate a collection for the purposes of documentation.&amp;nbsp;You can view all of this via the public workspace I have setup, or you can run in your Postman using the button below.







A collection providing a complete reference of the Jira Cloud Platform API, containing all of the possible APIs calls that you can make using the Jira API.



I use this Jira reference collection as the seed for all of my other collections. It provides me with the menu for the entire Jira &quot;kitchen&quot;, from which I can make many different meals, serving them up as part of my regular operations. When it comes to creating this type of API collection for consumers, there will be a portion of developers who want this full menu so that they can decide what they&amp;rsquo;d like to make. But, the majority of API consumers will prefer to have prepared dishes defined for them, providing just the most commonly used Jira ingredients put into separate containers and labeled to help them accomplish what they are looking to get done. Not everyone will have the time, bandwidth, and awareness of the entire Jira API to be able to make this collection work, which is why it helps to pull out individual capabilities for developers to put to work.
API Capability Collections
Once I have my full menu of Jira ingredients available, I can start pulling out some of the most commonly used features of Jira for individual use, or as part of workflow collections. While I can just reference these requests as part of the larger reference collection, it helps to have them defined as individual capabilities so that they can be used in a more modular way across API operations, documentation, and training. To get started, I am looking for the key capabilities that Jira provides me when it comes to moving forward API projects across teams, giving me the fundamental units of value reflecting why I use JIra, defined as individual collections that I can reuse and remix across other collection, but then more importantly use as part of API documentation and training. Here are a handful of Jira API capability collections I have created to help me in my work, and storytelling.







Jira - Capability - Add Label to Issue&amp;nbsp;- Providing a way to just add a single label to an issue.






Jira - Capability - Create Issue&amp;nbsp;- Creating new Jira issues for a variety of use cases.






Jira - Capability - Get Issue&amp;nbsp;- Pulling a single issue from Jira to work with in a variety of ways.






Jira - Capability - Remove a Label from an Issue&amp;nbsp;- Remove a label that has been applied to a single issue.






Jira - Capability - Search for Jira Issues&amp;nbsp;- Searching for Jira issues to find specific types of APIs using JQL.






Jira - Capability - Update Issue&amp;nbsp;- Updating the details of a single Jira Issue.



This list represents the core value for me of Jira, but also the capabilities I am wanting to use in a variety of workflow collections. As I do more API demos and workshops that involve the JIra API, or storytelling like this around what the Jira API enables, I will create more capability collections beyond these six. This list provides me what I need right now for demonstrating the difference between reference and capability collections, while also providing me with modular Jira capabilities I can use to on-board folks with the Jira API and Postman functionality with relevant API capabilities they put to use as part of their daily work. Allowing anyone who uses Jira to transcend the user interface and begin automating and orchestrating with the Jira platform without having to write any code&amp;mdash;using modular Postman API capability collections to drive API integration conversations.
API Workflow Collections
Now that I have the beginning of my API capability collection catalog for the JIRA API I can start assembling a variety of workflows I am looking at running manually, or as part of scheduled monitors. I have Jira pretty dialed in when it comes to managing my work at Postman, but I am looking to further automate, orchestrate, and augment my work using a variety of Jira API workflow collections. Defining workflow collections takes a whole other set of API design skills, going beyond what any single API provider or request can do, and stitching together a variety of API calls to accomplish a specific business task. Here are just a handful of API workflow collections I am playing around with to help me automate some of my daily work.







Workflow - Pull Jira Issue and Publish to Slack&amp;nbsp;- Pulling a single Jira issue then pulling specific details and publishing to a Slack conversation.






Workflow - Pull Tweets and Create Jira Task&amp;nbsp;- Pulling tweets from Twitter, grabbinb a single or several tweets and then publishing as a Jira task to track work around the tweet thread.



&amp;nbsp;The more time I spend carving off specific capability collection from the Jira API, the better I get at identifying what I need when it comes to crafting my workflows. If you look in&amp;nbsp;the public workspace for my Jira API work&amp;nbsp;you will notice there are individual capabilities for Twitter and Slack in there as well. Providing me with additonal modular API capability collections I can use as part of different workflows. This level of collection building is really the most meaningful and impactful, going beyond just APIs and speaking to the business value they generate each day. A complete reference collection for an API holds a lot of untapped potential, but as a consumer you will need have to have the motivation to make sense of the API and do the hard work of defining what the core capabilities are, and how they&amp;rsquo;ll be used to add real world business value. It becomes easier when you have a variety of modular capability collections, and growing experience sticking these capabilities together across a variety of API platforms.
Reference, Capability, and Workflow Collections are a Journey
The thing I love about this process is everything that I learn along the way. I have similar workspaces setup for Confluence, Github, Twitter, Postman, and other API platforms I depend on. While operating these public worksspaces I learn so much about each platform, but also how I put each platform to work as part of my operations. This is a journey that every API provider should be on with their own API, bringing their consumers along for the ride via a public workspace if possible. I known that many API providers feel that publishing documentation is enough for getting developers to build the next generation of applications and integrations, but few developers are going to understand the value present in your API like you do, and going through the motions of breaking your API resources out into more meaningful API-driven capabilities, then using those capabilities to accomplish specific business workflows will go a long way to demonstrating what is possible with your developers. You never know what this type of collection building and ultimately storytelling around it will inspire with your API consumers, unless you embark on this journey for your own stack of API resoiurces.
There are several critical dimensions to this journey. First there is the different types of collections, but then there is the collaboration and engagement that these collections bring to the table. You&amp;rsquo;ll notice that all of this work is available out in the open as a public workspace, so anyone from the community can learn from what is going on, and even pitch in by commenting or forking any of the collections. Additionally, I have published run in Postman buttons enabled for all of these collections so that I can publish the entire reference API collection, or any of the modular capability collections and resulting workflow collections to any wiki, website, portal, or Github repository for use by my readers. Remixing API capabilities into different workflows is pretty powerful juju, but once you augment this with documentation, blog posts, social media, demos, workshops, and other storytelling activities, you really begin to see the potential of this collection driven API journey. Then once you realize the potential of this journey when built on top of an OpenAPI platform, generating reference, capability, and workflow collections from a souurce of truth, you will find that a whole new world of API orchestration, automation, integration, and storytelling emerges&amp;mdash;changing not just how you consume APIs, but also produce APIs as part of your regular operations
]]></content>
    <id>http://localhost:4000/2020/12/19/reference-capability-and-workflow-jira-api-collections/</id>
  </entry><entry>
    <title>Pulling the OpenAPI For Any API You Are Managing With Postman So That You Can Apply Across the API Lifecycle</title>
    <link href="http://localhost:4000/2020/11/23/pulling-the-openapi-for-any-api-you-are-managing-with-postman-so-that-you-can-apply-across-the-api-lifecycle/"/>
    <updated></updated>
    <content><![CDATA[
I am using Postman to do more governance on my OpenAPI definitions as part of their API lifecycle. This is a top request of customers I am talking to, so I want to get better at make these individual API lifecycle capabilities much more modular and reusable as Postman collections. In Postman, the OpenAPI is the truth for each API contract throughout the API lifecycle, but each collection has become how you automate each stop along the API lifecycle. Resulting in me needing the OpenAPI for each API I am automating, and being able to pull the OpenAPI truth using the Postman API within each collection I am defining to mock, document, test, and govern each API.
You can find a single collection for pulling the OpenAPI for an API from the Postman API using it&amp;rsquo;s name (boy that is a mouthful). The collection is designed to abstract away three separate API calls into a single request. Ideally Postman will provide a similar API endpoint, but until that happens I have this collection to help make things easier. The documentation for the collection should provide you with everything you need to get up and running with the collection, pulling the API into a Postman environment for reuse. It is up to you to decide what you will do with the OpenAPI after that, possibly making multiple changes, and then saving back to Postman using the API.
If you have any questions on the collection for pulling the OpenAPI as part of the API lifecycle, feel free to submit a comment for the collection as part of the OpenAPI workspace. I&amp;rsquo;ll be centralizing the evolution of this collection, as well as other OpenAPI related collections within this workspace. You can also fork the collection and use in your workspaces, and submit back any enhancements you&amp;rsquo;d like to see as a pull request. If you have any questions that you don&amp;rsquo;t want to see in the comments for the collection, feel free to email me at [email&amp;#160;protected].
]]></content>
    <id>http://localhost:4000/2020/11/23/pulling-the-openapi-for-any-api-you-are-managing-with-postman-so-that-you-can-apply-across-the-api-lifecycle/</id>
  </entry><entry>
    <title>Managing the Scope of Your OpenAPI</title>
    <link href="http://localhost:4000/2020/11/18/managing-the-scope-of-your-openapi/"/>
    <updated></updated>
    <content><![CDATA[
Managing the size of an OpenAPI is a common challenge for API development teams. I have regular conversations with teams about the ways in which you can minimize the overall scope of an API, breaking things down into more manageable chunks, while also reducing redundancy&amp;mdash;then encouraging reuse. Like other dimensions of the API space there are differing opinions on whether it is better to have one single OpenAPI for all of your APIs, or whether it makes more sense to break things down into well defined bounded contexts. You can see this debate occurring in Monolith vs Microservices, and MonoRepo vs Multi-Repo discussions across the API space. In this game, there are no right or wrong answers, just different approaches that work well for different organizations, teams, and individuals. My goal is to help folks understand the trade-offs by informing them enough to make their own decisions and set into motion API design practices that keep the API factory floor moving along.
The size of your APIs matter. The size of your OpenAPI for your APIs matters. The scope, complexity, and consistency of your APIs will define how easy they are to maintain and put to work. Organizations that do not use OpenAPI struggle with being able to define the API landscape at all, let alone being able to define the scope of individual APIs or groups of APIs. It is common for API providers who are moving into the OpenAPI realm to slam into the brick wall of API scope right away, realizing their OpenAPI definitions are too big to work with in some services and tooling, and become a maze of complexity when it comes to maintenance and consumption. While there are many ways your API design practices can reduce or at least better define the scope of your APIs and resulting APIs, there are a handful of ways you can slice and dice your APIs up to make them easier to manage, or settle in with accepting that there is one monolith OpenAPI to rule them all!

Paths
The design of your resource-centric HTTP APIs will help or hinder your ability to spread the scope of your APIs across multiple files. Depending on the underlying schema model, and the types of resources being made available, as well as the API design training and guidance given to teams, the number and scope of API paths being served up will vary. If you have a coherent resource and sub-resource strategy it becomes easier to break things down into more manageable groupings. Helping break your APIs and the OpenAPIs that define them into much more meaningful and reusable chunks. API paths will define your OpenAPI journey, and define the complexity and breakdown of your API lifecycle, so make sure you are thinking about the design of API paths across all teams throughout your organization.&amp;nbsp;
Methods
How you use your HTTP methods as part of the API design process will help you downstream when it comes to breaking things down in your OpenAPI. Efficient use of GET, POST, PUT, and DELETE will help your OpenAPIs be more coherent, but it can also dictate the scope of other OpenAPI elements like parameters, headers, and the schema used within your request bodies. Your API design choices impact the overall scope of your API, something you might not realize until you've had to spend the time generating or crafting a complete OpenAPI definition for your API. How you express the methods of your API will help you define the scope of your APIs, the OpenAPIs that define them, as well as all the downstream effects of delivering and consuming an API&amp;mdash;make sure you have a plan for this layer.
Parameters
Adding to the dimensions of how your API design will define the scope of your API and OpenAPI, your usage of path and query parameters, as well as headers will shape how big or small your APIs are. Having an overall organization API design strategy will help lay the groundwork for the scope of the parameter layer of your APIs. Using common parameters for as much of this dimension will help you reuse parameters across APIs, and centralize them as part of your OpenAPI. Each unique parameter will add baggage to the surface area of an API, which is something that will have to be defined in an OpenAPI, adding to the overall scope of each API and resulting OpenAPI. Parameter sprawl is an easy trap to fall into, but once you spend the time laying out an overall API design strategy it is something that will become much more manageable for your team.

Tags
OpenAPI helps teams map out the surface area of their APIs so that they can see it. OpenAPI tags then allow you to start defining the bounded contexts in which each API path and method operates in. Providing you with the ability to begin slicing and dicing legacy API infrastructure into more meaningful groupings which can then possibly be segmented into separate OpenAPI files, and then versioned and evolved to become more in alignment with the overall API design strategy. Helping you define, understand, manage, evolve, then sensibly reduce or increase scope across the API landscape. OpenAPI tags are how you are going to do this work, and begin making sense of the API landscape that exists across your organization, but then also be able to become more coherent in how you community across teams when it comes to delivering and consuming APIs.
Components
The components object represents the greatest opportunity for API providers to be moving from Swagger 2.0 to OpenAPI 3.0, and begin to get a handle on the scope of APIs, and your OpenAPI. The OpenAPI components object lets you centralize common schema responses, parameters, examples, request bodies, headers, security schemes, links, and callbacks, and then just reference them across your OpenAPI wherever they are needed with a $ref. This component centralization and reuse will become your biggest ally when it comes to managing the scope of your API. Components provide you with a single reusable toolbox of the components you need to apply across each of your APIs, providing an in-file components library that helps you logically define the scope of your API with well planned lego bricks rather than every part of your OpenAPI being a custom block.
Files
Once you begin getting your API design house in order, and get more organized about how you use the OpenAPI specification to map out your API landscape, including having your APIs well tagged with logical bounded contexts, you will become more efficient with breaking your OpenAPIs up into separate files. Leveraging your tag work you can split up monolith OpenAPI documents into separate OpenAPI files which can then be used independently of each other. Helping you load balance the scope of your OpenAPI across many files, providing a well organized selection of smaller, more precise OpenAPIs rather than relying on everything being in a single file. Of course, there are tradeoffs to having to navigate multiple files, but it depends on whether you like your complexity vertically or horizontally--either way you will have to work through the paths, schema, and other parts and pieces.

External $ref
Once you have things broken into separate files you can begin to use external references to each of the moving parts. One place to begin is to break out the schema for your APIs as separate JSON Schema files which can be referenced using an external $ref where they are applied within an OpenAPI, but then you can also use this individual JSON Schema files for validation and other purposes across your operations. External references allow you to break things up into separate files, potentially setting up a centralized components library, which can just be referenced from wherever they are needed. In addition to the schema sprawl introduced by this approach, not all OpenAPI enabled tooling will support external references, requiring the rehydration of files before imported or put to work within services and tooling, further balancing out the tradeoffs around API scope.
Start Managing OpenAPI Scope Today
I know that many folks will just opt for the easier route of having a single monolith OpenAPI, but that will just push the technical debt and complexity down the road. At some point you will have to manage OpenAPI scope and you are better off starting as early as you can. As stated several times, having an organizational wide API design strategy will inform how you manage the scope of your API, but thinking about scope at the path, method, and parameter levels, while leveraging tags and components to optimize the scope of each of your OpenAPIs can bring a lot of benefits. You can still remain a mono OpenAPI, but actively work to manage scope. However, if you have thousands of APIs being developed, iterated upon, and delivered across your organization I highly recommend beginning investing in separate files and external references, as this is where you will begin to see the biggest bang for your buck when it comes to managing the scope of your OpenAPIs.
The scope and complexity of your OpenAPI will be a mirror of your API scope and complexity, which is a mirror of your organizational scope and complexity. If creating and managing an OpenAPI seems unwieldy it is because the design and complexity of your API has become unwieldy. Most people who begin on their OpenAPI journey do so to deliver API Documentation, but then they quickly realize how OpenAPI is much for than just documenting what is going on for consumers. Managing your OpenAPI becomes about managing your API operations and the lifecycle you employ to deliver, iterate upon, and support your APIs. OpenAPI scope is often an illusion based upon operating for years without being able to see the entire API landscape--once you generate that first OpenAPI and begin to get intimate with all the moving parts, you quickly begin to see a bigger picture where scope is more about the lack of visibility and manage practices in the past, which is something that becomes radically amplified by the maturing of your API design and governance strategy&amp;mdash;but that is another story.
]]></content>
    <id>http://localhost:4000/2020/11/18/managing-the-scope-of-your-openapi/</id>
  </entry><entry>
    <title>Some API Specification Toolbox Projects That Will Make an Impact</title>
    <link href="http://localhost:4000/2020/11/12/some-api-specification-toolbox-projects-that-will-make-an-impact/"/>
    <updated></updated>
    <content><![CDATA[
 
I have been conducting weekly discussions around API specifications each Friday mornings which I call the API Specification Toolbox. The goal is to just identify ways in which we can drive more discussion and participation in API specifications, focusing on OpenAPI, AsyncAPI, JSON Schema, GraphQL, and Postman Collections. My goal is to help increase awareness of these specifications, but more importantly get more people sharing what they are working on and invest more time and resources into supporting the specifications. I conduct an hour of informal discussions from 8:00 AM to 9:00 AM PST each Friday, and we record as many of our ideas and talking points on Github using issues. Some interesting ideas have emerged from the discussion, and I am taking some of the lowest hanging fruit from these ideas, organizing them, and working with the OAI, AsyncAPI, JSON Schema, and Postman team to try and bring some of these ideas to life.&amp;nbsp; There are many other ideas that didn&amp;rsquo;t make my starter list of project, but these are the ones I feel are the most important, would have the the greatest impact, and be achievable in small bursts of work, and to help drive some conversation I am having, I wanted to flesh out some of the top ideas here on the blog.
I cleaned up the titles for each of these ideas, and grouped them based upon the type of project, and I would like to flesh out a little more, identify how they overlap and are related&amp;mdash;then work to actually push them forward without me doing all of the work. I feel like with some assistance from the wider API community, and some investment from the OAI, AsyncAPI, JSON Schema, and Postman, these projects could make a pretty significant impact on what is going on across the API landscapes. My objective with this post is to show how all of these projects can feed each other, and see what I can convince the community, and each specification to help move forward. Providing me with the words I am going to need to sell these ideas to anyone who will listen, and potentially help make things actually happen.
Mapping The Landscape
I feel this area is one of the cornerstone deficiencies that slows the forward motion of the specifications, services, and tooling. In my opinion, everything is dependent on these four areas, meaning if we can clearly articulate the services, tooling, and people involved with these API specifications, and understand how they are extending the specification, all of these specifications and resulting tooling will lurch forward without any clear vision or coherency. As a community, we need to be able to efficiently profile and publish directories of services, tooling, people, and extensions, and do it in a way that can paint a full picture of what is going on. These are the four core projects I feel are needed to map the API specification landscape.

 Service Providers #19 - Identifying, profiling, and publishing a directory of API service providers who have adopted API specifications.
Open Source Tools #7 - Identifying, profiling, and publishing a directory of open source API tooling who developed on top of API specifications.
People #20 - Identifying, profiling, and publishing a directory of people who are working on the specifications, and doing things with them.
Specification Extension #24 - Identifying, profiling, and publishing a directory of specification extensions that are in use across the space.




I pulled together a simple Jekyll single page application that runs 100% on Github for service providers and for tooling, and can apply the same &amp;ldquo;toolbox&amp;rdquo; approach to people and extensions. It provides an open format that anyone can fork and replicate, publishing their own full or sub-directory. Next, I wanted to identify a handful of things that will be needed to move these forward to help drive some conversations about more investment in making these directories happen&amp;mdash;here is what I am thinking about right now.&amp;nbsp;

 Single Page Application - I already have a blueprint for these single page catalogs that are driven using the APIs.json specification, and use Jekyll and Github Pages to allow them to run 100% for free on Github. I have written up the approach, and will be working to apply to these projects as work gets done.
Intake Questionnaire - We need an intake questionnaire for each of these directories that can be used when approaching service providers, and tooling creators, as well as a checklist when profiling people and vendor extensions, making the process that anyone can do to help move things forward.
Discovery - While I have pulled together a seed list for service providers and tooling, there will be a lot more work ahead to find new ones, as well as work to find interesting people and what the different extensions are for each of the specifications, bringing new entries to each of these API specification catalogs.&amp;nbsp;
Outreach - We will need one or many people to actually reach out to service providers and tooling creators, and encourage them to fill out the intake questionnaire, then add the information to the APIs.json data stores behind each of the directories, building out the catalogs and ensuring information is correct.
Research - It will take a significant amount of research to find people who are doing interesting things with API specifications, and discover the extensions that exist out there, with an emphasis and focus on OpenAPI extensions to begin with, demonstrating how folks are extending the specification.
Evangelization&amp;nbsp;- It will take some serious evangelism to help get the word out about these directories as they are being built, pushing the service providers, tooling, and people to help spread the word as they are being engaged, as well as invest in ongoing storytelling and amplification about the directories in an ongoing way.



I am using GitHub to move each of these projects forward. There should be an issue added for each service provider, tool, person, and extension. This provides a feedback loop to be established that people who are working on the catalogs can use to record activity and engage with the community. Each issue can be used to handle intake for each entry, evolve each of them, and provide an ongoing feedback loop for each entry, as well as each catalog. It is going to be tough to put a scope and price tag on all of this work, but it seems like there should be a set amount of hours each month that can be dedicated to this work, and recruiting volunteers as well as a handful of paid workers. As I will demonstrate, this work will lay the foundation for other projects I am advocating for, as well as help strengthen and grow the entire API economy.

Self-Service Virtual Storytelling
The next group of projects I would like to see invested in after mapping out the landscape, involves telling the stories and incentivizing conversations about why API specifications matter, and what people are doing with them. All three of these ideas overlap with each other when it comes to content, topics, and potentially coordination. Making them pretty ripe for doing all together, helping provide a rich set of ongoing conversations about the specifications and what they enable.&amp;nbsp;

 Video Interviews #3 - Conducting a regular stream of video interviews with people who are developing the specifications, as well as what people are doing with them across APII service and tooling providers, as well as API providers themselves, and possibly the developers who are integrating with the APIs that use them.
Podcast #25 - This could be a pure audio version of the same video interviews above. Maybe we only do one of the formats, but ideally they are done as video interviews, and the audio gets mixed and published as a podcast, covering a wider spectrum of viewers and listeners who may want to engage in different ways.
Forums &amp;amp; Workshops #8 - Moving beyond just interviews and conversations around the specs and service and tooling space, regular forums could be held that teach people about specifications, tooling, and common practices provided regularly scheduled forums and workshops that help educate the growing API specification community.&amp;nbsp;



These interviews, conversations, and forums could be cultivated from the work above on mapping the API landscape. Bringing in service providers, tooling creators, and people doing interesting things across the space, and getting them involved in doing the interviews, participating in the conversations, and leading the forums and workshops. Here are some of the elements that will be needed to help move some of these things forward as part of these projects.

 Participant Discovery - Finding the people who will be engaged in these interviews, conversations, forums, and workshops.&amp;nbsp;
Participant Handling - There will be work to handle the scheduling and coordination needed to keep a steady stream of people.
Topic Discovery - More work is needed to make sure relevant topics are discovered and brought to the table for this storytelling.
Video and Audio Production - There will be regular work to edit and produce each of the videos and podcasts being published.
Publishing and Syndication - Once a video or podcast is ready it will take work to publish and syndicate across relevant channels.
Single Page Application - It would be nice to also publish a single landing page that catalogs all of this content as part of the effort.



I am sure there is a lot more work to be done here, but I am just looking to get the main talking points down right now. Then I will open up for discussion during the API Specification Toolbox office hours, and as part of the conversation I am having with the OAI, AsyncAPI, JSON Schema, and at Postman. I really see this self-service virtual storytelling and the mapping of the API landscape all working together in a virtuous cycle that expands the awareness and literacy around API specifications.

Information and Propaganda
The last grouping of ideas I&amp;rsquo;d like to see happen. I am dubbing information and propaganda because it is all about further expanding the narrative and visual storytelling that exists around the specification. Rounding of the virtual storytelling above with a regular heartbeat from a newsletter, as well as more static longer form content and visual storytelling that helps reinforce what API specifications deliver, and the impact they are making across the software development lifecycle. Here are the three projects I&amp;rsquo;d love to see get some investment from the community as well as the API specifications themselves.&amp;nbsp;

 Community Newsletter #12 - Putting out a regular newsletter that showcases the specifications, services, tooling, people, and interesting conversations going on across the sector.
10 White Papers #5 - Produce a series of white papers that showcase the impact API specifications make on the API lifecycle on the ground within enterprise organizations, providing an overview of what people need to know.
Propaganda Posters #9 - Add a visual layer to the API specification conversation, developing a series of old school propaganda posters that get people motivated about API specifications, and collecting the different posters defining this time of technology.



I have already started pulling together a handful of pilot newsletters, fleshing out the format and topics&amp;mdash;I just haven&amp;rsquo;t sent them or built the lists. I haven&amp;rsquo;t done any work on the white papers or propaganda posters, but would like to actually start detailing what they may be about. I think these are great projects to bring together the community and the specifications, while providing a regular drumbeat about the space, and reliable content that newcomers can use to get up to speed, and keepsakes that the most passionate can collect to capture a piece of this moment. To help move these projects forward, here are some of the areas I would need to work on fleshing out a bit more.

 Newsletter Format - I have already pulled together a proposed format outline for the newsletter, and pulled together issue one and two, trying to seed this project.
Weekly Newsletter - Providing dedicated resources that would actually pull together the newsletter each week based upon submissions, and get out the door.
White Paper Topics - Pick 10 (more or less) topics for each of the API specification white papers, providing what people are needing to learn about the most.
Find White Paper Authors - Identify the authors who are best suited for actually creating each of the API specification white papers.
Produce White Paper Content - Actually write each of the white papers and then edit them, getting them ready for production.
Publish White Papers - Formerly produce each of the white papers, putting a polish on them and getting ready for public consumption.
Syndication - Invest in actually publishing and syndicating each of the white papers, helping make them available outside the specifications.
Poster Topics - Identify the topics for each of the propaganda posters, picking the most impactful areas in which API specifications are making a difference.
Poster Artist - Find an artist who can actually produce each of the propaganda posters, and provide use with the finished product that will work.
Poster Syndication - Establish a strategy for making the posters available and get them out to the community in a way that will make them memorable and exposed.




These are just talking points I can use to help drive some of the conversations I am having. There will be a lot of things to do that I am not seeing, but I wanted to make a first pass at what the scope of these projects might be. Clearly the newsletter will take an ongoing effort, but the white papers and propaganda will take a heavy one time lift, with light touches after that. While we may not be tackling all of these, I wanted to lay them out in hopes that we can at least tackle one or two of them.&amp;nbsp;
Stabilizing and Amplifying the API Specification Toolbox
The service provider, tooling, people, and extensions directories would help us define the API landscape. This would have a stabilizing effect on the conversation. Helping people understand what exists, but more importantly help us stabilize what will and should come next. Then the virtual events, information, and propaganda will help amplify this increasingly well defined API specification driven landscape. It is crazy that there isn&amp;rsquo;t an authoritative source of services and tooling, and I am always amazed at how interested folks are into talking and sharing knowledge about the API specifications, with so few outlets for all of this to occur. I am regularly amazed at what I come across going on with OpenAPI, AsyncAPI, JSON Schema, and Postman collections as I do my work as the Chief Evangelist for Postman, and API Evangelist each day. I come across compelling stories coming out of top tier API providers about how they are using all of these specifications, with an appetite for telling these stories, and there are very few specification centric outlets to point them to. There is the API specification conference, which was born out of my event API Strategy &amp;amp; Practice, but beyond this there isn&amp;rsquo;t anything else dedicated to the growing API specification dimension of the API economy.
OpenAPI, AsyncAPI, JSON Schema, and Postman Collections are defining almost every industry in 2020, mapping out the data, content, algorithms that are powering business today. These API specifications are defining the resources behind the desktop, web, mobile, device, and network applications powering our personal and professional worlds. API specifications have grown significantly over the last ten years, and we are going to have to ramp up our investment in these specs if we are going to take things to the next level and realize the potential of what we have all been calling the &amp;ldquo;API Economy&amp;rdquo;.&amp;nbsp; I feel like this list of ideas represents how we can light the fire under all of this and begin stabilizing the conversation and driving it all forward. I just have to figure out how to make it all happen without me carrying the entire load. I am already moving some of these projects forward in one way or another, but to be able to do it at the scale we need I am going to need more people and investment from the specifications, services, and tooling providers. Alright, now back to the dog and pony show around this production, selling it to the people I need to help me move this stuff forward&amp;mdash;more to come as I further refine each of these ideas and come up with actual plans for executing on them.
]]></content>
    <id>http://localhost:4000/2020/11/12/some-api-specification-toolbox-projects-that-will-make-an-impact/</id>
  </entry><entry>
    <title>An OpenAPI and Postman Collections for the Census API</title>
    <link href="http://localhost:4000/2020/09/10/an-openapi-and-postman-collections-for-the-census-api/"/>
    <updated></updated>
    <content><![CDATA[I am including the U.S. Census API in a couple of different projects in the queue, and to help me make the API more discoverable and usable by developers I needed an OpenAPI and Postman collection for the API. Helping make it easier for developers to on-board with the Census API, but also provide a base collection I can use to develop additional workflow collections that help provide specific types of data easier to use in variety of use cases. Our data API partners over at Metadata Technology North America (MTNA) is helping us deploy APIs on top of some valuable datasets as part of our COVID-19 resource center, and they offered to help us develop the OpenAPI and Postman collection for the U.S. Census API.
Carson Hunter (@carrrson) from MTNA got to work crafting an OpenAPI 3.0 for the Census API, providing a pretty robust source of truth for the API, which we can then use to generate Postman collections to document, mock, test, and automate around the Census API, but also just use the collection as a client for running different queues and saving the results of API responses to files without having to write code. Carson did the extra work of also creating a Postman collection and publishing as documentation, helping make the API a little easier to navigate, while also making sure there is a &amp;ldquo;Run in Postman&quot; button available so that developers can quickly begin putting to work within their own Postman workspaces. Carson helped reduce the friction when it comes to onboarding with the Census API, while also helping me make it more discoverable as part of the various API projects I am working on.
There is a lot more work we can do on these reference OpenAPI and Postman collection, but we wanted to just pause and put out there for others to comment on what they would like to see. We have published the OpenAPI and Postman collection for the Census API to a GitHub repository, where anyone can fork, download, and put to use. We would love to hear any feedback or requests via the GitHub issues, helping us ensure future work more useful to the wider community. I am going to see what I can do to get the Census Bureau to add the Postman collection to the Postman network, adding to the discoverability and onboarding for the API, but then also keep brainstorming with Carson and the MTNA team about what other Census API resources we should be adding, or maybe how we can layer in visualizations on top of common queries, helping make it easier for developers or even non-developers to make sense of the massive amount of data the Census API provides access to. We are just going to spread out our work on the U.S. Census API, helping break things into smaller more bit size chunks, while also opening our work up for community feedback.

If you depend on the Census API, or have an application or integration you&amp;rsquo;d like to develop on top of the API, I&amp;rsquo;d love to hear more about it. I have a couple of projects in the works which are building on top of the OpenAPI and Postman collection that MTNA has developed. I am looking for additional use cases to drive future collection development. The Census API plays a pivotal role in a variety of important discussions, and there is pretty significant opportunity to make Census data more accessible and usable as part of these discussions, while also making the conversations more inclusive, allowing folks to work with Census data without writing code. I&amp;rsquo;ve seen how the Census API has widened the playing field for who works with Census data firsthand since 2011. Before then it was just the bigger data players who were downloading the massive data files and making sense of the surveys. The API has made the data more accessible in smaller chunks to a wider audience, beyond only those who have the resources and skills to work with large data sets. I am looking to continue this evolution by developing a variety of Postman collections that help make working with the Census data easier, and establish a variety of workspaces and repositories for developers to get up and running with the Census API quicker. Let me know where you project fits into this picture, and how we can put this OpenAPI and Postman collection to work as part of whatever you are cooking up.
]]></content>
    <id>http://localhost:4000/2020/09/10/an-openapi-and-postman-collections-for-the-census-api/</id>
  </entry><entry>
    <title>Twitter OpenAPI, Docs, and Mocks in a Workspace</title>
    <link href="http://localhost:4000/2020/09/02/twitter-openapi-docs-and-mocks-in-a-workspace/"/>
    <updated></updated>
    <content><![CDATA[I am working on several demonstrations of what is possible when you use OpenAPI on the Postman platform, and as part of this storytelling I want to use the OpenAPI of leading API platforms to demonstrate what is possible. I am looking to showcase the potential of using an OpenAPI as a base of the API integration and development lifecycle, and today I wanted to showcase what you can quickly do when you put the OpenAPI for the Twitter API into a Postman workspace.

This OpenAPI can act as the truth for a variety of lifecycle activities, but to begin with I usually generate two collections. One for providing reference documentation for the entire API, and another to provide me with a mock representation of the entire surface area of the API, helping me articulate what the API does to team members, while also kicking the etires on it before I have to obtain a token or key.

This approach isn't unique to the Twitter API, and can be used by API providers to guide the development of APIs, or it can be done by API consumers to help localize documentation, mock servers, and other resources you will need to work with an API. If you want to see it in action you can walk through a short video, showing how you can do this in just a few minutes using Postman.

]]></content>
    <id>http://localhost:4000/2020/09/02/twitter-openapi-docs-and-mocks-in-a-workspace/</id>
  </entry>
</feed>
